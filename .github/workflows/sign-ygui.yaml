name: Sign YASB GUI Artifacts

on:
  repository_dispatch:
    types: [sign-external]

permissions:
  contents: read
  actions: write

jobs:
  sign:
    runs-on: windows-latest
    
    steps:
    - name: Validate payload
      run: |
        $payload = '${{ toJson(github.event.client_payload) }}' | ConvertFrom-Json
        if (-not $payload.source_repo) { throw "Missing source_repo" }
        if (-not $payload.files -or $payload.files.Count -eq 0) { throw "Missing files" }
        if (-not $payload.mode) { throw "Missing mode (artifact or release)" }
        
        Write-Host "=== Signing Request ==="
        Write-Host "  Source: $($payload.source_repo)"
        Write-Host "  Mode: $($payload.mode)"
        Write-Host "  Stage: $($payload.callback_stage)"
        Write-Host "  Files: $($payload.files -join ', ')"
        Write-Host "  Config: $($payload.artifact_configuration)"
        
        if ($payload.mode -eq 'artifact') {
          Write-Host "  Run ID: $($payload.run_id)"
          Write-Host "  Input artifact: $($payload.input_artifact_name)"
          Write-Host "  Output artifact: $($payload.output_artifact_name)"
        } else {
          Write-Host "  Release ID: $($payload.release_id)"
          Write-Host "  Release Tag: $($payload.release_tag)"
        }
      shell: pwsh

    - name: Download from source artifact
      if: github.event.client_payload.mode == 'artifact'
      uses: actions/github-script@v7
      env:
        SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
        RUN_ID: ${{ github.event.client_payload.run_id }}
        ARTIFACT_NAME: ${{ github.event.client_payload.input_artifact_name }}
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          
          const [owner, repo] = process.env.SOURCE_REPO.split('/');
          const runId = parseInt(process.env.RUN_ID);
          const artifactName = process.env.ARTIFACT_NAME;
          
          console.log(`Looking for artifact "${artifactName}" in run ${runId}`);
          
          // List artifacts in the source workflow run
          const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
            owner, repo, run_id: runId
          });
          
          const artifact = artifacts.artifacts.find(a => a.name === artifactName);
          if (!artifact) {
            console.log('Available artifacts:', artifacts.artifacts.map(a => a.name));
            throw new Error(`Artifact "${artifactName}" not found`);
          }
          
          console.log(`Found artifact: ${artifact.name} (ID: ${artifact.id}, Size: ${artifact.size_in_bytes} bytes)`);
          
          // Download artifact
          const { data: download } = await github.rest.actions.downloadArtifact({
            owner, repo,
            artifact_id: artifact.id,
            archive_format: 'zip'
          });
          
          // Save and extract
          fs.mkdirSync('unsigned', { recursive: true });
          const zipPath = 'artifact.zip';
          fs.writeFileSync(zipPath, Buffer.from(download));
          
          execSync(`powershell -Command "Expand-Archive -Path '${zipPath}' -DestinationPath 'unsigned' -Force"`);
          fs.unlinkSync(zipPath);
          
          console.log('Artifact downloaded and extracted');

    - name: Download from source release
      if: github.event.client_payload.mode == 'release'
      uses: actions/github-script@v7
      env:
        SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
        RELEASE_ID: ${{ github.event.client_payload.release_id }}
        FILES: ${{ toJson(github.event.client_payload.files) }}
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          
          const [owner, repo] = process.env.SOURCE_REPO.split('/');
          const releaseId = parseInt(process.env.RELEASE_ID);
          const filesToDownload = JSON.parse(process.env.FILES);
          
          const { data: release } = await github.rest.repos.getRelease({
            owner, repo, release_id: releaseId
          });
          
          console.log(`Found ${release.assets.length} assets in release`);
          fs.mkdirSync('unsigned', { recursive: true });
          
          for (const fileName of filesToDownload) {
            const asset = release.assets.find(a => a.name === fileName);
            if (!asset) {
              throw new Error(`Asset ${fileName} not found in release`);
            }
            
            console.log(`Downloading ${fileName} (${(asset.size / 1024 / 1024).toFixed(2)} MB)...`);
            
            const { url } = await github.rest.repos.getReleaseAsset({
              owner, repo,
              asset_id: asset.id,
              headers: { accept: 'application/octet-stream' }
            });
            
            const response = await fetch(url);
            const buffer = Buffer.from(await response.arrayBuffer());
            fs.writeFileSync(path.join('unsigned', fileName), buffer);
          }

    - name: List downloaded files
      run: |
        Get-ChildItem -Path unsigned -Recurse | ForEach-Object { 
          Write-Host "  $($_.Name) ($([math]::Round($_.Length/1MB, 2)) MB)"
        }
      shell: pwsh

    - name: Prepare artifact
      uses: actions/upload-artifact@v4
      with:
        name: signpath-input
        path: unsigned/*

    - name: Get artifact ID
      id: get_artifact
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const { owner, repo } = context.repo;
          const run_id = context.runId;
          
          let artifact = null;
          for (let i = 0; i < 10; i++) {
            await new Promise(resolve => setTimeout(resolve, 3000));
            const res = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
            artifact = res.data.artifacts.find(a => a.name === 'signpath-input');
            if (artifact) break;
            console.log(`Attempt ${i + 1}: Waiting for artifact...`);
          }
          
          if (!artifact) throw new Error('Artifact not found');
          console.log(`Found artifact ID: ${artifact.id}`);
          return artifact.id;

    - name: Submit signing request
      id: sign
      uses: signpath/github-action-submit-signing-request@v1
      with:
        api-token: '${{ secrets.SIGN_TOKEN }}'
        organization-id: '9efb6764-d1fc-46c5-b050-5ef07bb67a8c'
        project-slug: 'yasb'
        signing-policy-slug: '${{ github.event.client_payload.signing_policy }}'
        artifact-configuration-slug: '${{ github.event.client_payload.artifact_configuration }}'
        github-artifact-id: '${{ steps.get_artifact.outputs.result }}'
        wait-for-completion: true
        output-artifact-directory: 'signed'

    - name: Verify signed files
      if: steps.sign.outcome == 'success'
      run: |
        if (-not (Test-Path 'signed')) { throw "Signed directory not found" }
        $files = Get-ChildItem -Path signed -File -Recurse
        if ($files.Count -eq 0) { throw "No signed files found" }
        Write-Host "=== Signed files ==="
        foreach ($f in $files) {
          Write-Host "  $($f.Name) ($([math]::Round($f.Length/1MB, 2)) MB)"
        }
      shell: pwsh

    - name: Upload signed artifact for source repo
      if: steps.sign.outcome == 'success' && github.event.client_payload.mode == 'artifact'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ github.event.client_payload.output_artifact_name }}
        path: signed/*
        retention-days: 1

    - name: Upload signed files to source release
      if: steps.sign.outcome == 'success' && github.event.client_payload.mode == 'release'
      uses: actions/github-script@v7
      env:
        SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
        RELEASE_ID: ${{ github.event.client_payload.release_id }}
        FILES: ${{ toJson(github.event.client_payload.files) }}
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          
          const [owner, repo] = process.env.SOURCE_REPO.split('/');
          const releaseId = parseInt(process.env.RELEASE_ID);
          const originalFiles = JSON.parse(process.env.FILES);
          
          const { data: release } = await github.rest.repos.getRelease({
            owner, repo, release_id: releaseId
          });
          
          for (const fileName of originalFiles) {
            const existingAsset = release.assets.find(a => a.name === fileName);
            if (existingAsset) {
              console.log(`Deleting unsigned: ${fileName}`);
              await github.rest.repos.deleteReleaseAsset({
                owner, repo, asset_id: existingAsset.id
              });
            }
            
            const filePath = path.join('signed', fileName);
            if (!fs.existsSync(filePath)) throw new Error(`Signed file not found: ${filePath}`);
            
            const fileData = fs.readFileSync(filePath);
            console.log(`Uploading signed: ${fileName}`);
            
            await github.rest.repos.uploadReleaseAsset({
              owner, repo, release_id: releaseId,
              name: fileName,
              data: fileData
            });
          }

    - name: Trigger success callback
      if: steps.sign.outcome == 'success'
      uses: actions/github-script@v7
      env:
        SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
        RUN_ID: ${{ github.event.client_payload.run_id }}
        RELEASE_ID: ${{ github.event.client_payload.release_id }}
        RELEASE_TAG: ${{ github.event.client_payload.release_tag }}
        CALLBACK_EVENT: ${{ github.event.client_payload.callback_event }}
        CALLBACK_STAGE: ${{ github.event.client_payload.callback_stage }}
        MODE: ${{ github.event.client_payload.mode }}
        OUTPUT_ARTIFACT: ${{ github.event.client_payload.output_artifact_name }}
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const [owner, repo] = process.env.SOURCE_REPO.split('/');
          const callbackEvent = process.env.CALLBACK_EVENT || 'signing-complete';
          
          const payload = {
            status: 'success',
            stage: process.env.CALLBACK_STAGE,
            mode: process.env.MODE,
            signed_by: 'amnweb/yasb',
            yasb_run_id: context.runId
          };
          
          if (process.env.MODE === 'artifact') {
            payload.output_artifact_name = process.env.OUTPUT_ARTIFACT;
            payload.source_run_id = parseInt(process.env.RUN_ID);
            if (process.env.RELEASE_ID) {
              payload.release_id = parseInt(process.env.RELEASE_ID);
            }
          } else {
            payload.release_id = parseInt(process.env.RELEASE_ID);
            payload.release_tag = process.env.RELEASE_TAG;
          }
          
          console.log(`Triggering ${callbackEvent} on ${owner}/${repo}`);
          console.log('Payload:', JSON.stringify(payload, null, 2));
          
          await github.rest.repos.createDispatchEvent({
            owner, repo,
            event_type: callbackEvent,
            client_payload: payload
          });

    - name: Trigger failure callback
      if: failure()
      uses: actions/github-script@v7
      env:
        SOURCE_REPO: ${{ github.event.client_payload.source_repo }}
        RUN_ID: ${{ github.event.client_payload.run_id }}
        RELEASE_ID: ${{ github.event.client_payload.release_id }}
        CALLBACK_EVENT: ${{ github.event.client_payload.callback_event }}
        CALLBACK_STAGE: ${{ github.event.client_payload.callback_stage }}
      with:
        github-token: ${{ secrets.YGUI_TOKEN }}
        script: |
          const [owner, repo] = process.env.SOURCE_REPO.split('/');
          const callbackEvent = process.env.CALLBACK_EVENT || 'signing-complete';
          
          await github.rest.repos.createDispatchEvent({
            owner, repo,
            event_type: callbackEvent,
            client_payload: {
              status: 'failed',
              stage: process.env.CALLBACK_STAGE,
              source_run_id: process.env.RUN_ID ? parseInt(process.env.RUN_ID) : null,
              release_id: process.env.RELEASE_ID ? parseInt(process.env.RELEASE_ID) : null,
              signed_by: 'amnweb/yasb',
              run_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
            }
          });

    - name: Cleanup
      if: always()
      uses: geekyeggo/delete-artifact@v5
      with:
        name: signpath-input
        failOnError: false
