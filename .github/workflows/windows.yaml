name: Windows build

on:
  workflow_dispatch:
    inputs:
      cx_freeze_version:
        description: 'cx_Freeze version to use'
        required: true
        default: 'stable'
        type: choice
        options:
          - stable
          - dev

permissions:
  contents: read

env:
  PYTHON_VERSION: '3.14'

jobs:
  build:
    permissions:
      contents: write
    strategy:
      matrix:
        include:
          - arch: x64
            runner: windows-latest
            python_arch: x64
            artifact_suffix: x64
            unsigned_exe_name: unsigned-exes-x64
            unsigned_msi_name: unsigned-msi-x64
          - arch: arm64
            runner: windows-11-arm
            python_arch: arm64
            artifact_suffix: aarch64
            unsigned_exe_name: unsigned-exes-arm64
            unsigned_msi_name: unsigned-msi-arm64
    runs-on: ${{ matrix.runner }}
    name: Build (${{ matrix.arch }})
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        architecture: ${{ matrix.python_arch }}

    - name: Create virtual environment
      run: |
        python -m venv venv
      shell: pwsh

    - name: Activate virtual environment and install dependencies
      run: |
        .\venv\Scripts\Activate
        python -m pip install --upgrade pip
        pip install --force --no-cache .
        if ("${{ github.event.inputs.cx_freeze_version }}" -eq "dev") {
          Write-Host "Installing cx_Freeze dev version from test.pypi.org"
          pip install --extra-index-url https://test.pypi.org/simple/ cx_Freeze --pre --no-cache
        } else {
          Write-Host "Installing cx_Freeze stable version"
          pip install --force --no-cache --upgrade cx_Freeze
        }
      shell: pwsh

    - name: Build EXE
      run: |
        .\venv\Scripts\Activate
        cd src
        python build.py build
      shell: pwsh

    - name: Upload unsigned EXE artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.unsigned_exe_name }}
        path: |
          src/dist/yasb.exe
          src/dist/yasbc.exe
          src/dist/yasb_themes.exe

    - name: Get unsigned-exes artifact id
      id: get_exes_artifact
      uses: actions/github-script@v7
      env:
        ARTIFACT_NAME: ${{ matrix.unsigned_exe_name }}
      with:
        github-token: ${{ secrets.PAT }}
        script: |
          const { owner, repo } = context.repo;
          const run_id = context.runId;
          const expectedName = process.env.ARTIFACT_NAME;
          const res = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
          const artifact = res.data.artifacts.find(a => a.name === expectedName);
          if (!artifact) throw new Error(`${expectedName} artifact not found`);
          return artifact.id;

    - name: Submit EXE signing request
      id: sign_exes
      uses: signpath/github-action-submit-signing-request@v1
      with:
        api-token: '${{ secrets.SIGN_TOKEN }}'
        organization-id: '9efb6764-d1fc-46c5-b050-5ef07bb67a8c'
        project-slug: 'yasb'
        signing-policy-slug: '${{ secrets.SIGN_POLICY_SLUG }}'
        artifact-configuration-slug: 'signing_executable'
        github-artifact-id: '${{ steps.get_exes_artifact.outputs.result }}'
        wait-for-completion: 'true'
        output-artifact-directory: 'src/signed'

    - name: Replace unsigned EXE with signed
      if: steps.sign_exes.outcome == 'success'
      run: |
        .\venv\Scripts\Activate
        $signedDir = 'src/signed'
        if (-not (Test-Path $signedDir)) {
          Write-Host "Signed artifacts directory $signedDir not found. Ensure SignPath places signed files there.";
          exit 1
        }
        # Copy signed EXEs into the distribution folder; fail if none found
        $signedExes = Get-ChildItem -Path $signedDir -File -Filter '*.exe' -Recurse -ErrorAction SilentlyContinue
        if ($null -eq $signedExes -or $signedExes.Count -eq 0) {
          Write-Error "No signed .exe files found in $signedDir after extraction. Failing the job."
          exit 1
        }
        Write-Host "Copying signed EXEs from $signedDir to src/dist"
        foreach ($f in $signedExes) {
          Copy-Item -Path $f.FullName -Destination (Join-Path 'src/dist' $f.Name) -Force
        }
        # Clean up signed directory after successful copy
        try {
          Get-ChildItem -Path $signedDir -Recurse -Force | Remove-Item -Force -Recurse
          Write-Host "Cleaned up $signedDir"
        } catch {
          Write-Warning "Failed to clean up ${signedDir}: $($_.Exception.Message)"
        }
      shell: pwsh

    - name: Build MSI
      run: |
        .\venv\Scripts\Activate
        cd src
        python build.py bdist_msi
      shell: pwsh

    - name: Upload unsigned MSI
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.unsigned_msi_name }}
        path: src/dist/out/*.msi

    - name: Get unsigned-msi artifact id
      id: get_msi_artifact
      uses: actions/github-script@v7
      env:
        ARTIFACT_NAME: ${{ matrix.unsigned_msi_name }}
      with:
        github-token: ${{ secrets.PAT }}
        script: |
          const { owner, repo } = context.repo;
          const run_id = context.runId;
          const expectedName = process.env.ARTIFACT_NAME;
          const res = await github.rest.actions.listWorkflowRunArtifacts({ owner, repo, run_id });
          const artifact = res.data.artifacts.find(a => a.name === expectedName);
          if (!artifact) throw new Error(`${expectedName} artifact not found`);
          return artifact.id;

    - name: Submit MSI signing request
      id: sign_msi
      uses: signpath/github-action-submit-signing-request@v1
      with:
        api-token: '${{ secrets.SIGN_TOKEN }}'
        organization-id: '9efb6764-d1fc-46c5-b050-5ef07bb67a8c'
        project-slug: 'yasb'
        signing-policy-slug: '${{ secrets.SIGN_POLICY_SLUG }}'
        artifact-configuration-slug: 'signing_installer'
        github-artifact-id: '${{ steps.get_msi_artifact.outputs.result }}'
        wait-for-completion: 'true'
        output-artifact-directory: 'src/signed'

    - name: Replace unsigned MSI with signed
      if: steps.sign_msi.outcome == 'success'
      run: |
        .\venv\Scripts\Activate
        $signedDir = 'src/signed'
        if (-not (Test-Path $signedDir)) {
          Write-Host "Signed artifacts directory $signedDir not found. Ensure SignPath places signed files there.";
          exit 1
        }
        # Copy signed MSIs into the output folder; fail if none found
        $signedMsis = Get-ChildItem -Path $signedDir -File -Filter '*.msi' -Recurse -ErrorAction SilentlyContinue
        if ($null -eq $signedMsis -or $signedMsis.Count -eq 0) {
          Write-Error "No signed .msi files found in $signedDir after extraction. Failing the job."
          exit 1
        }
        Write-Host "Copying signed MSIs from $signedDir to src/dist/out"
        foreach ($f in $signedMsis) {
          Copy-Item -Path $f.FullName -Destination (Join-Path 'src/dist/out' $f.Name) -Force
        }
        # Clean up signed directory after successful copy
        try {
          Get-ChildItem -Path $signedDir -Recurse -Force | Remove-Item -Force -Recurse
          Write-Host "Cleaned up $signedDir"
        } catch {
          Write-Warning "Failed to clean up ${signedDir}: $($_.Exception.Message)"
        }
      shell: pwsh

    - name: Prepare MSI for Upload
      env:
        ARTIFACT_SUFFIX: ${{ matrix.artifact_suffix }}
      run: |
        .\venv\Scripts\Activate
        $version = (Get-Content src/settings.py | Select-String -Pattern 'BUILD_VERSION\s*=\s*"([^"]+)"').Matches.Groups[1].Value
        $msis = Get-ChildItem -Path src/dist/out/*.msi
        if (-not $msis) {
          Write-Error "No MSI files found to rename."
          exit 1
        }
        if ($msis.Count -gt 1) {
          Write-Warning "Multiple MSI files found; using the first entry $($msis[0].FullName)."
        }
        $sourceMsi = $msis[0].FullName
        $targetName = "yasb-$version-$($env:ARTIFACT_SUFFIX).msi"
        $targetMsi = Join-Path 'src/dist/out' $targetName
        Write-Host "Renaming MSI from $sourceMsi to $targetMsi"
        Copy-Item -Path $sourceMsi -Destination $targetMsi -Force
        if ($sourceMsi -ne $targetMsi) {
          Remove-Item -Path $sourceMsi -Force
        }
        # Store filename for later steps (only from x64 build to avoid conflicts)
        if ($env:ARTIFACT_SUFFIX -eq 'x64') {
          echo "FILENAME=$targetName" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        }
      shell: pwsh

    - name: Upload Built MSI
      uses: actions/upload-artifact@v4
      with:
        name: built-msi-${{ matrix.artifact_suffix }}
        path: src/dist/out/*.msi

    - name: Delete Artifacts
      if: github.event_name == 'workflow_dispatch'
      uses: geekyeggo/delete-artifact@v5
      with:
        name: |
          unsigned-*
          signed-*

  release:
    needs: build
    runs-on: windows-latest
    permissions:
      contents: write
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Create virtual environment
      run: |
        python -m venv venv
      shell: pwsh

    - name: Download all MSI artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: built-msi-*
        path: dist-msis
        merge-multiple: true

    - name: Get App Info
      id: get_version
      run: |
        .\venv\Scripts\Activate
        $version = (Get-Content src/settings.py | Select-String -Pattern 'BUILD_VERSION\s*=\s*"([^"]+)"').Matches.Groups[1].Value
        echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "VERSION=$version" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
      shell: pwsh
      
    - name: Create Tag
      id: create_tag
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.PAT }}
        script: |
          const version = `v${process.env.VERSION}`;
          const { owner, repo } = context.repo;
          const sha = context.sha;
          try {
            const { data: tags } = await github.rest.repos.listTags({
              owner,
              repo,
            });
            const tagExists = tags.some(tag => tag.name === version);
            if (!tagExists) {
              console.log(`Creating tag ${version}`);
              await github.rest.git.createRef({
                owner,
                repo,
                ref: `refs/tags/${version}`,
                sha,
              });
            } else {
              console.log(`Tag ${version} already exists, skipping tag creation`);
            }
          } catch (error) {
            console.error(`Error fetching tags: ${error.message}`);
            throw error;
          }

    - name: Fetch all tags
      run: git fetch --tags
      shell: pwsh

    - name: Create Changelog
      id: changelog
      uses: loopwerk/tag-changelog@v1.3.0
      with:
        token: ${{ secrets.PAT }}
        config_file: .github/changelog/changelog.js
        
    - name: Create Backward Compatibility Copy
      run: |
        .\venv\Scripts\Activate
        $x64Msi = Get-ChildItem -Path dist-msis -Filter "yasb-*-x64.msi" | Select-Object -First 1
        if ($x64Msi) {
          $version = $env:VERSION
          $fallbackName = "yasb-$version-win64.msi"
          $fallbackPath = Join-Path "dist-msis" $fallbackName
          Copy-Item -Path $x64Msi.FullName -Destination $fallbackPath -Force
          Write-Host "Created backward compatibility copy: $fallbackName"
        } else {
          Write-Warning "x64 MSI not found, skipping backward compatibility copy"
        }
      shell: pwsh

    - name: Generate Checksum
      run: |
        .\venv\Scripts\Activate
        $checksums = Get-FileHash dist-msis/*.msi -Algorithm SHA256
        $output = @()
        foreach ($checksum in $checksums) {
          $filename = [System.IO.Path]::GetFileName($checksum.Path)
          $output += "$($checksum.Hash) $filename"
        }
        $output -join "`n" > dist-msis/checksums.txt
      shell: pwsh

    - name: Create and Upload Release
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ steps.get_version.outputs.VERSION }}
        name: v${{ steps.get_version.outputs.VERSION }}
        body: | 
              ${{ steps.changelog.outputs.changes }}
        append_body: true
        files: |
          dist-msis/*.msi
          dist-msis/checksums.txt
        prerelease: false
        generate_release_notes: true
        draft: true
      env:
        GITHUB_TOKEN: ${{ secrets.PAT }}
